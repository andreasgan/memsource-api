/*
 * Memsource REST API
 *
 * Welcome to Memsource's API documentation. To view our legacy APIs please [visit our documentation](https://wiki.memsource.com/wiki/Memsource_API) and for more information about our new APIs, [visit our blog](https://www.memsource.com/blog/2017/10/24/introducing-rest-apis-qa-with-the-memsource-api-team/).    If you have any questions, please contact [Memsource Support](https://get-help.memsource.com).
 *
 * API version: All
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type JobApiService service

/*
JobApiService Compare jobs on workflow levels

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiComparePartOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReadyReferences) -
     * @param "AtWorkflowLevel" (optional.Int32) -
     * @param "WithWorkflowLevel" (optional.Int32) -

@return ComparedSegmentsDto
*/

type JobApiComparePartOpts struct {
	Body              optional.Interface
	AtWorkflowLevel   optional.Int32
	WithWorkflowLevel optional.Int32
}

func (a *JobApiService) ComparePart(ctx context.Context, projectUid string, localVarOptionals *JobApiComparePartOpts) (ComparedSegmentsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ComparedSegmentsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AtWorkflowLevel.IsSet() {
		localVarQueryParams.Add("atWorkflowLevel", parameterToString(localVarOptionals.AtWorkflowLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithWorkflowLevel.IsSet() {
		localVarQueryParams.Add("withWorkflowLevel", parameterToString(localVarOptionals.WithWorkflowLevel.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReadyReferences)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be JobPartReadyReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ComparedSegmentsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Download target file
This call will return target file with translation. This means even for other jobs that were created via &#39;split jobs&#39; etc.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiCompletedFileOpts - Optional Parameters:
     * @param "Format" (optional.String) -


*/

type JobApiCompletedFileOpts struct {
	Format optional.String
}

func (a *JobApiService) CompletedFile(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiCompletedFileOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/targetFile"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Create job
 Job file can be provided directly in the message body or downloaded from connector.   Please supply job metadata in &#x60;Memsource&#x60; header.   For file in the request body provide also the filename in &#x60;Content-Disposition&#x60; header.  Accepted metadata:     - &#x60;targetLangs&#x60; - **required**   - &#x60;due&#x60; - ISO 8601   - &#x60;workflowSettings&#x60; - project with workflow - see examples bellow   - &#x60;assignments&#x60; - project without workflows - see examples bellow   - &#x60;importSettings&#x60; - re-usable import settings - see [Create import settings](#operation/createImportSettings)   - &#x60;useProjectFileImportSettings&#x60; - mutually exclusive with importSettings   - &#x60;callbackUrl&#x60; - consumer callback   - &#x60;path&#x60; - original destination directory      for remote file jobs also &#x60;remoteFile&#x60; - see examples bellow:   - &#x60;connectorToken&#x60; - remote connector token   - &#x60;remoteFolder&#x60;    - &#x60;remoteFileName&#x60;   - &#x60;continuous&#x60; - true for continuous job  Create and assign job in project without workflow step: &#x60;&#x60;&#x60;  {   \&quot;targetLangs\&quot;: [     \&quot;cs_cz\&quot;   ],   \&quot;callbackUrl\&quot;: \&quot;https://my-shiny-service.com/consumeCallback\&quot;,   \&quot;importSettings\&quot;: {     \&quot;uid\&quot;: \&quot;abcd123\&quot;   },   \&quot;due\&quot;: \&quot;2007-12-03T10:15:30.00Z\&quot;,   \&quot;path\&quot;: \&quot;destination directory\&quot;,   \&quot;assignments\&quot;: [     {       \&quot;targetLang\&quot;: \&quot;cs_cz\&quot;,       \&quot;providers\&quot;: [         {           \&quot;id\&quot;: \&quot;4321\&quot;,           \&quot;type\&quot;: \&quot;USER\&quot;         }       ]     }   ],   \&quot;notifyProvider\&quot;: {     \&quot;organizationEmailTemplate\&quot;: {       \&quot;id\&quot;: \&quot;39\&quot;     },     \&quot;notificationIntervalInMinutes\&quot;: \&quot;10\&quot;   } } &#x60;&#x60;&#x60;  Create job from remote file without workflow steps: &#x60;&#x60;&#x60;  {   \&quot;remoteFile\&quot;: {     \&quot;connectorToken\&quot;: \&quot;948123ef-e1ef-4cd3-a90e-af1617848af3\&quot;,     \&quot;remoteFolder\&quot;: \&quot;/\&quot;,     \&quot;remoteFileName\&quot;: \&quot;Few words.docx\&quot;,     \&quot;continuous\&quot;: false   },   \&quot;assignments\&quot;: [],   \&quot;workflowSettings\&quot;: [],   \&quot;targetLangs\&quot;: [     \&quot;cs\&quot;   ] } &#x60;&#x60;&#x60;  Create and assign job in project with workflow step: &#x60;&#x60;&#x60;  {   \&quot;targetLangs\&quot;: [     \&quot;de\&quot;   ],   \&quot;useProjectFileImportSettings\&quot;: \&quot;true\&quot;,   \&quot;workflowSettings\&quot;: [     {       \&quot;id\&quot;: \&quot;64\&quot;,       \&quot;due\&quot;: \&quot;2007-12-03T10:15:30.00Z\&quot;,       \&quot;assignments\&quot;: [         {           \&quot;targetLang\&quot;: \&quot;de\&quot;,           \&quot;providers\&quot;: [             {               \&quot;id\&quot;: \&quot;3\&quot;,               \&quot;type\&quot;: \&quot;VENDOR\&quot;             }           ]         }       ],       \&quot;notifyProvider\&quot;: {         \&quot;organizationEmailTemplate\&quot;: {           \&quot;id\&quot;: \&quot;39\&quot;         },         \&quot;notificationIntervalInMinutes\&quot;: \&quot;10\&quot;       }     }   ] } &#x60;&#x60;&#x60;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiCreateJobOpts - Optional Parameters:
     * @param "Memsource" (optional.String) -
     * @param "ContentDisposition" (optional.String) -  must match pattern &#x60;((inline|attachment); )?(filename\\*&#x3D;UTF-8&#39;&#39;(.+)|filename&#x3D;\&quot;?(.+)\&quot;?)&#x60;
     * @param "Body" (optional.Interface of InputStream) -

@return JobListDto
*/

type JobApiCreateJobOpts struct {
	Memsource          optional.String
	ContentDisposition optional.String
	Body               optional.Interface
}

func (a *JobApiService) CreateJob(ctx context.Context, projectUid string, localVarOptionals *JobApiCreateJobOpts) (JobListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Memsource.IsSet() {
		localVarHeaderParams["Memsource"] = parameterToString(localVarOptionals.Memsource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ContentDisposition.IsSet() {
		localVarHeaderParams["Content-Disposition"] = parameterToString(localVarOptionals.ContentDisposition.Value(), "")
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(InputStream)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be InputStream")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v JobListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Create term in job&#39;s term bases
Create new term in the write term base assigned to the job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobUid
 * @param projectUid
 * @param optional nil or *JobApiCreateTermByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of CreateTermsDto) -

@return TermPairDto
*/

type JobApiCreateTermByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) CreateTermByJob(ctx context.Context, jobUid string, projectUid string, localVarOptionals *JobApiCreateTermByJobOpts) (TermPairDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TermPairDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/termBases/createByJob"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(CreateTermsDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be CreateTermsDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TermPairDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Delete all translations

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiDeleteAllTranslationsOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReadyReferences) -


*/

type JobApiDeleteAllTranslationsOpts struct {
	Body optional.Interface
}

func (a *JobApiService) DeleteAllTranslations(ctx context.Context, projectUid string, localVarOptionals *JobApiDeleteAllTranslationsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReadyReferences)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be JobPartReadyReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Delete job (batch)

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiDeletePartsOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReferences) -
     * @param "Purge" (optional.Bool) -


*/

type JobApiDeletePartsOpts struct {
	Body  optional.Interface
	Purge optional.Bool
}

func (a *JobApiService) DeleteParts(ctx context.Context, projectUid string, localVarOptionals *JobApiDeletePartsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Purge.IsSet() {
		localVarQueryParams.Add("purge", parameterToString(localVarOptionals.Purge.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReferences)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be JobPartReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Edit job

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiEditPartOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartUpdateSingleDto) -

@return JobPartExtendedDto
*/

type JobApiEditPartOpts struct {
	Body optional.Interface
}

func (a *JobApiService) EditPart(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiEditPartOpts) (JobPartExtendedDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartExtendedDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartUpdateSingleDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be JobPartUpdateSingleDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartExtendedDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Edit jobs (batch)
 Returns only jobs which were updated by the batch operation.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiEditPartsOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartUpdateBatchDto) -

@return JobPartsDto
*/

type JobApiEditPartsOpts struct {
	Body optional.Interface
}

func (a *JobApiService) EditParts(ctx context.Context, projectUid string, localVarOptionals *JobApiEditPartsOpts) (JobPartsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartUpdateBatchDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be JobPartUpdateBatchDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Download preview file
Takes bilingual file (.mxliff only) as argument. If not passed, data will be taken from database
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiFilePreviewOpts - Optional Parameters:
     * @param "Body" (optional.Interface of InputStream) -


*/

type JobApiFilePreviewOpts struct {
	Body optional.Interface
}

func (a *JobApiService) FilePreview(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiFilePreviewOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(InputStream)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be InputStream")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Download preview file

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid


*/
func (a *JobApiService) FilePreviewJob(ctx context.Context, projectUid string, jobUid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Download bilingual file

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiGetBilingualFileOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReadyReferences) -
     * @param "Format" (optional.String) -


*/

type JobApiGetBilingualFileOpts struct {
	Body   optional.Interface
	Format optional.String
}

func (a *JobApiService) GetBilingualFile(ctx context.Context, projectUid string, localVarOptionals *JobApiGetBilingualFileOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/bilingualFile"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReadyReferences)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be JobPartReadyReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Get target file&#39;s warnings
 This call will return target file&#39;s warnings. This means even for other jobs that were created via &#39;split jobs&#39; etc.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return TargetFileWarningsDto
*/
func (a *JobApiService) GetCompletedFileWarnings(ctx context.Context, projectUid string, jobUid string) (TargetFileWarningsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TargetFileWarningsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/targetFileWarnings"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TargetFileWarningsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Download original file

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid


*/
func (a *JobApiService) GetOriginalFile(ctx context.Context, projectUid string, jobUid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/original"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Get job

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return JobPartExtendedDto
*/
func (a *JobApiService) GetPart(ctx context.Context, projectUid string, jobUid string) (JobPartExtendedDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartExtendedDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartExtendedDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get job&#39;s workflowStep

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return ProjectWorkflowStepDto
*/
func (a *JobApiService) GetPartsWorkflowStep(ctx context.Context, projectUid string, jobUid string) (ProjectWorkflowStepDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ProjectWorkflowStepDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/workflowStep"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ProjectWorkflowStepDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get segments count
Provides segments count (progress data)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiGetSegmentsCountOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReadyReferences) -

@return SegmentsCountsResponseListDto
*/

type JobApiGetSegmentsCountOpts struct {
	Body optional.Interface
}

func (a *JobApiService) GetSegmentsCount(ctx context.Context, projectUid string, localVarOptionals *JobApiGetSegmentsCountOpts) (SegmentsCountsResponseListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SegmentsCountsResponseListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/segmentsCount"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReadyReferences)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be JobPartReadyReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SegmentsCountsResponseListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get translation resources

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return TranslationResourcesDto
*/
func (a *JobApiService) GetTranslationResources(ctx context.Context, projectUid string, jobUid string) (TranslationResourcesDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TranslationResourcesDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/translationResources"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TranslationResourcesDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService List analyses

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiListPartAnalyseOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -
     * @param "PageSize" (optional.Int32) -

@return PageDtoAnalyseDto
*/

type JobApiListPartAnalyseOpts struct {
	PageNumber optional.Int32
	PageSize   optional.Int32
}

func (a *JobApiService) ListPartAnalyse(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiListPartAnalyseOpts) (PageDtoAnalyseDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PageDtoAnalyseDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/analyses"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v PageDtoAnalyseDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService List analyses

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiListPartAnalyse1Opts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -
     * @param "PageSize" (optional.Int32) -

@return PageDtoAnalyseV2Dto
*/

type JobApiListPartAnalyse1Opts struct {
	PageNumber optional.Int32
	PageSize   optional.Int32
}

func (a *JobApiService) ListPartAnalyse1(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiListPartAnalyse1Opts) (PageDtoAnalyseV2Dto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PageDtoAnalyseV2Dto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/{jobUid}/analyses"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v PageDtoAnalyseV2Dto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService List jobs

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiListPartsOpts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -
     * @param "PageSize" (optional.Int32) -
     * @param "Count" (optional.Bool) -
     * @param "WorkflowLevel" (optional.Int32) -
     * @param "Status" (optional.Interface of []string) -
     * @param "AssignedLinguist" (optional.Int64) -
     * @param "DueInHours" (optional.Int32) -
     * @param "Filename" (optional.String) -
     * @param "TargetLang" (optional.String) -

@return PageDtoJobPartReference
*/

type JobApiListPartsOpts struct {
	PageNumber       optional.Int32
	PageSize         optional.Int32
	Count            optional.Bool
	WorkflowLevel    optional.Int32
	Status           optional.Interface
	AssignedLinguist optional.Int64
	DueInHours       optional.Int32
	Filename         optional.String
	TargetLang       optional.String
}

func (a *JobApiService) ListParts(ctx context.Context, projectUid string, localVarOptionals *JobApiListPartsOpts) (PageDtoJobPartReference, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PageDtoJobPartReference
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WorkflowLevel.IsSet() {
		localVarQueryParams.Add("workflowLevel", parameterToString(localVarOptionals.WorkflowLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedLinguist.IsSet() {
		localVarQueryParams.Add("assignedLinguist", parameterToString(localVarOptionals.AssignedLinguist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueInHours.IsSet() {
		localVarQueryParams.Add("dueInHours", parameterToString(localVarOptionals.DueInHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filename.IsSet() {
		localVarQueryParams.Add("filename", parameterToString(localVarOptionals.Filename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetLang.IsSet() {
		localVarQueryParams.Add("targetLang", parameterToString(localVarOptionals.TargetLang.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v PageDtoJobPartReference
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService List jobs

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiListPartsV2Opts - Optional Parameters:
     * @param "PageNumber" (optional.Int32) -
     * @param "PageSize" (optional.Int32) -
     * @param "Count" (optional.Bool) -
     * @param "WorkflowLevel" (optional.Int32) -
     * @param "Status" (optional.Interface of []string) -
     * @param "AssignedUser" (optional.Int64) -
     * @param "DueInHours" (optional.Int32) -
     * @param "Filename" (optional.String) -
     * @param "TargetLang" (optional.String) -
     * @param "AssignedVendor" (optional.Int64) -

@return PageDtoJobPartReferenceV2
*/

type JobApiListPartsV2Opts struct {
	PageNumber     optional.Int32
	PageSize       optional.Int32
	Count          optional.Bool
	WorkflowLevel  optional.Int32
	Status         optional.Interface
	AssignedUser   optional.Int64
	DueInHours     optional.Int32
	Filename       optional.String
	TargetLang     optional.String
	AssignedVendor optional.Int64
}

func (a *JobApiService) ListPartsV2(ctx context.Context, projectUid string, localVarOptionals *JobApiListPartsV2Opts) (PageDtoJobPartReferenceV2, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PageDtoJobPartReferenceV2
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WorkflowLevel.IsSet() {
		localVarQueryParams.Add("workflowLevel", parameterToString(localVarOptionals.WorkflowLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedUser.IsSet() {
		localVarQueryParams.Add("assignedUser", parameterToString(localVarOptionals.AssignedUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueInHours.IsSet() {
		localVarQueryParams.Add("dueInHours", parameterToString(localVarOptionals.DueInHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filename.IsSet() {
		localVarQueryParams.Add("filename", parameterToString(localVarOptionals.Filename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetLang.IsSet() {
		localVarQueryParams.Add("targetLang", parameterToString(localVarOptionals.TargetLang.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedVendor.IsSet() {
		localVarQueryParams.Add("assignedVendor", parameterToString(localVarOptionals.AssignedVendor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v PageDtoJobPartReferenceV2
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get suggested providers

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return ProviderListDto
*/
func (a *JobApiService) ListProviders1(ctx context.Context, projectUid string, jobUid string) (ProviderListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ProviderListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/providers/suggest"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ProviderListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get segments

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiListSegmentsOpts - Optional Parameters:
     * @param "BeginIndex" (optional.Int32) -
     * @param "EndIndex" (optional.Int32) -

@return SegmentListDto
*/

type JobApiListSegmentsOpts struct {
	BeginIndex optional.Int32
	EndIndex   optional.Int32
}

func (a *JobApiService) ListSegments(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiListSegmentsOpts) (SegmentListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SegmentListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.BeginIndex.IsSet() {
		localVarQueryParams.Add("beginIndex", parameterToString(localVarOptionals.BeginIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIndex.IsSet() {
		localVarQueryParams.Add("endIndex", parameterToString(localVarOptionals.EndIndex.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SegmentListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Notify assigned users

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiNotifyAssignedOpts - Optional Parameters:
     * @param "Body" (optional.Interface of NotifyJobPartsRequestDto) -


*/

type JobApiNotifyAssignedOpts struct {
	Body optional.Interface
}

func (a *JobApiService) NotifyAssigned(ctx context.Context, projectUid string, localVarOptionals *JobApiNotifyAssignedOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/notifyAssigned"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(NotifyJobPartsRequestDto)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be NotifyJobPartsRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Get PDF preview

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiPreviewUrlsOpts - Optional Parameters:
     * @param "WorkflowLevel" (optional.Int32) -

@return PreviewUrlsDto
*/

type JobApiPreviewUrlsOpts struct {
	WorkflowLevel optional.Int32
}

func (a *JobApiService) PreviewUrls(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiPreviewUrlsOpts) (PreviewUrlsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PreviewUrlsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/previewUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.WorkflowLevel.IsSet() {
		localVarQueryParams.Add("workflowLevel", parameterToString(localVarOptionals.WorkflowLevel.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v PreviewUrlsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Pseudo-translate job

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiPseudoTranslateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobPartReadyReferences) -
     * @param "Replacement" (optional.String) -
     * @param "Prefix" (optional.String) -
     * @param "Suffix" (optional.String) -
     * @param "Length" (optional.Float64) -


*/

type JobApiPseudoTranslateOpts struct {
	Body        optional.Interface
	Replacement optional.String
	Prefix      optional.String
	Suffix      optional.String
	Length      optional.Float64
}

func (a *JobApiService) PseudoTranslate(ctx context.Context, projectUid string, localVarOptionals *JobApiPseudoTranslateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/pseudoTranslate"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Replacement.IsSet() {
		localVarQueryParams.Add("replacement", parameterToString(localVarOptionals.Replacement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prefix.IsSet() {
		localVarQueryParams.Add("prefix", parameterToString(localVarOptionals.Prefix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Suffix.IsSet() {
		localVarQueryParams.Add("suffix", parameterToString(localVarOptionals.Suffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Length.IsSet() {
		localVarQueryParams.Add("length", parameterToString(localVarOptionals.Length.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobPartReadyReferences)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be JobPartReadyReferences")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Pseudo-translates job

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiPseudoTranslateJobPartOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PseudoTranslateActionDto) -


*/

type JobApiPseudoTranslateJobPartOpts struct {
	Body optional.Interface
}

func (a *JobApiService) PseudoTranslateJobPart(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiPseudoTranslateJobPartOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/pseudoTranslate"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(PseudoTranslateActionDto)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be PseudoTranslateActionDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Search job&#39;s translation memories
&lt;b&gt;This API is incorrectly implemented, use             endpoint &lt;a href&#x3D;\&quot;#operation/searchSegmentByJob\&quot;&gt;Search translation memory for segment by job&lt;/a&gt;.&lt;/b&gt; &lt;/br&gt;             Returns at most &lt;i&gt;maxSegments&lt;/i&gt; records with &lt;i&gt;score &gt;&#x3D; scoreThreshold&lt;/i&gt; and at most             &lt;i&gt;maxSubsegments&lt;/i&gt; records which are subsegment, i.e. the source text is substring of the query text.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSearchByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTmByJobRequestDto) -

@return SearchResponseListTmDto
*/

type JobApiSearchByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchByJob(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSearchByJobOpts) (SearchResponseListTmDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/transMemories/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTmByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTmByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search job&#39;s translation memories

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSearchByJob2Opts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTmByJobRequestDtoV2) -

@return SearchResponseListTmDtoV2
*/

type JobApiSearchByJob2Opts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchByJob2(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSearchByJob2Opts) (SearchResponseListTmDtoV2, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDtoV2
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/{jobUid}/transMemories/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTmByJobRequestDtoV2)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTmByJobRequestDtoV2")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDtoV2
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search job&#39;s translation memories

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSearchByJob3Opts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTmByJobRequestDtoV3) -

@return SearchResponseListTmDtoV3
*/

type JobApiSearchByJob3Opts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchByJob3(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSearchByJob3Opts) (SearchResponseListTmDtoV3, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDtoV3
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v3/projects/{projectUid}/jobs/{jobUid}/transMemories/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTmByJobRequestDtoV3)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTmByJobRequestDtoV3")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDtoV3
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search jobs in project

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiSearchPartsInProjectOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchJobsRequestDto) -

@return SearchJobsDto
*/

type JobApiSearchPartsInProjectOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchPartsInProject(ctx context.Context, projectUid string, localVarOptionals *JobApiSearchPartsInProjectOpts) (SearchJobsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchJobsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchJobsRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchJobsRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchJobsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search translation memory for segment by job
Returns at most &lt;i&gt;maxSegments&lt;/i&gt;             records with &lt;i&gt;score &gt;&#x3D; scoreThreshold&lt;/i&gt; and at most &lt;i&gt;maxSubsegments&lt;/i&gt; records which are subsegment,             i.e. the source text is substring of the query text.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSearchSegmentByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTmByJobRequestDto) -

@return SearchResponseListTmDto
*/

type JobApiSearchSegmentByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchSegmentByJob(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSearchSegmentByJobOpts) (SearchResponseListTmDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/transMemories/searchSegment"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTmByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTmByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search job&#39;s term bases
Search all read term bases assigned to the job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobUid
 * @param projectUid
 * @param optional nil or *JobApiSearchTermsByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTbByJobRequestDto) -

@return SearchResponseListTbDto
*/

type JobApiSearchTermsByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchTermsByJob(ctx context.Context, jobUid string, projectUid string, localVarOptionals *JobApiSearchTermsByJobOpts) (SearchResponseListTbDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTbDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/termBases/searchByJob"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTbByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTbByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTbDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search job&#39;s term bases
Search all read term bases assigned to the job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobUid
 * @param projectUid
 * @param optional nil or *JobApiSearchTermsByJob1Opts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTbByJobRequestDto) -

@return SearchTbResponseListDto
*/

type JobApiSearchTermsByJob1Opts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchTermsByJob1(ctx context.Context, jobUid string, projectUid string, localVarOptionals *JobApiSearchTermsByJob1Opts) (SearchTbResponseListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchTbResponseListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/{jobUid}/termBases/searchByJob"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTbByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTbByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchTbResponseListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search terms in text
Search in text in all read term bases assigned to the job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobUid
 * @param projectUid
 * @param optional nil or *JobApiSearchTermsInTextByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchInTextByJobRequestDto) -

@return SearchInTextResponseListDto
*/

type JobApiSearchTermsInTextByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchTermsInTextByJob(ctx context.Context, jobUid string, projectUid string, localVarOptionals *JobApiSearchTermsInTextByJobOpts) (SearchInTextResponseListDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchInTextResponseListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/termBases/searchInTextByJob"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchInTextByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchInTextByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchInTextResponseListDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Search terms in text
Search in text in all read term bases assigned to the job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobUid
 * @param projectUid
 * @param optional nil or *JobApiSearchTermsInTextByJobV2Opts - Optional Parameters:
     * @param "Body" (optional.Interface of SearchTbInTextByJobRequestDto) -

@return SearchInTextResponseList2Dto
*/

type JobApiSearchTermsInTextByJobV2Opts struct {
	Body optional.Interface
}

func (a *JobApiService) SearchTermsInTextByJobV2(ctx context.Context, jobUid string, projectUid string, localVarOptionals *JobApiSearchTermsInTextByJobV2Opts) (SearchInTextResponseList2Dto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchInTextResponseList2Dto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/{jobUid}/termBases/searchInTextByJob"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SearchTbInTextByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SearchTbInTextByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchInTextResponseList2Dto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Edit job status

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSetStatusOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobStatusChangeActionDto) -


*/

type JobApiSetStatusOpts struct {
	Body optional.Interface
}

func (a *JobApiService) SetStatus(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSetStatusOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/setStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(JobStatusChangeActionDto)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be JobStatusChangeActionDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
JobApiService Split job
 Splits job by one of the following methods: * **After specific segments** - fill in &#x60;segmentOrdinals&#x60; * **Into X parts** - fill in &#x60;partCount&#x60;  * **Into parts with specific size** - fill in &#x60;partSize&#x60;. partSize represents segment count in each part. * **Into parts with specific word count** - fill in &#x60;wordCount&#x60;   * **By document parts** - fill in &#x60;byDocumentParts&#x60;, works only with **PowerPoint** files   Only one option at a time is allowed.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiSplitOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SplitJobActionDto) -

@return JobPartsDto
*/

type JobApiSplitOpts struct {
	Body optional.Interface
}

func (a *JobApiService) Split(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiSplitOpts) (JobPartsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(SplitJobActionDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be SplitJobActionDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get status changes

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid

@return JobPartStatusChangesDto
*/
func (a *JobApiService) StatusChanges(ctx context.Context, projectUid string, jobUid string) (JobPartStatusChangesDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartStatusChangesDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/statusChanges"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartStatusChangesDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Upload bilingual file
Returns updated job parts
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobApiUploadBilingualFileOpts - Optional Parameters:
     * @param "Body" (optional.Interface of InputStream) -
     * @param "Format" (optional.String) -
     * @param "SaveToTransMemory" (optional.String) -
     * @param "SetCompleted" (optional.Bool) -

@return JobPartsDto
*/

type JobApiUploadBilingualFileOpts struct {
	Body              optional.Interface
	Format            optional.String
	SaveToTransMemory optional.String
	SetCompleted      optional.Bool
}

func (a *JobApiService) UploadBilingualFile(ctx context.Context, localVarOptionals *JobApiUploadBilingualFileOpts) (JobPartsDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue JobPartsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/bilingualFiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SaveToTransMemory.IsSet() {
		localVarQueryParams.Add("saveToTransMemory", parameterToString(localVarOptionals.SaveToTransMemory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SetCompleted.IsSet() {
		localVarQueryParams.Add("setCompleted", parameterToString(localVarOptionals.SetCompleted.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(InputStream)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be InputStream")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobPartsDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get Web Editor URL
 Possible warning codes are:    - &#x60;NOT_ACCEPTED_BY_LINGUIST&#x60; - Job is not accepted by linguist    - &#x60;NOT_ASSIGNED_TO_LINGUIST&#x60; - Job is not assigned to linguist    - &#x60;PDF&#x60; - One of requested jobs is PDF   - &#x60;PREVIOUS_WORKFLOW_NOT_COMPLETED&#x60; - Previous workflow step is not completed    - &#x60;PREVIOUS_WORKFLOW_NOT_COMPLETED_STRICT&#x60; - Previous workflow step is not completed and project has strictWorkflowFinish set to true  Possible error codes are:    - &#x60;ASSIGNED_TO_OTHER_USER&#x60; - Job is accepted by other user    - &#x60;NOT_UNIQUE_TARGET_LANG&#x60; - Requested jobs contains different target locales    - &#x60;TOO_MANY_SEGMENTS&#x60; - Count of requested job&#39;s segments is higher than **40000**    Warning response example: &#x60;&#x60;&#x60; {     \&quot;warnings\&quot;: [         {             \&quot;message\&quot;: \&quot;Not accepted by linguist\&quot;,             \&quot;args\&quot;: {                 \&quot;jobs\&quot;: [                     \&quot;abcd1234\&quot;                 ]             },             \&quot;code\&quot;: \&quot;NOT_ACCEPTED_BY_LINGUIST\&quot;         },         {             \&quot;message\&quot;: \&quot;Previous workflow step not completed\&quot;,             \&quot;args\&quot;: {                 \&quot;jobs\&quot;: [                     \&quot;abcd1234\&quot;                 ]             },             \&quot;code\&quot;: \&quot;PREVIOUS_WORKFLOW_NOT_COMPLETED\&quot;         }     ],     \&quot;url\&quot;: \&quot;/web/job/abcd1234-efgh5678/translate\&quot; } &#x60;&#x60;&#x60;  Error response example: Status: &#x60;400 Bad Request&#x60; &#x60;&#x60;&#x60; {     \&quot;errorCode\&quot;: \&quot;NOT_UNIQUE_TARGET_LANG\&quot;,     \&quot;errorDescription\&quot;: \&quot;Only files with identical target languages can be joined\&quot;,     \&quot;errorDetails\&quot;: [         {             \&quot;code\&quot;: \&quot;NOT_UNIQUE_TARGET_LANG\&quot;,             \&quot;args\&quot;: {                 \&quot;targetLocales\&quot;: [                     \&quot;de\&quot;,                     \&quot;en\&quot;                 ]             },             \&quot;message\&quot;: \&quot;Only files with identical target languages can be joined\&quot;         },         {             \&quot;code\&quot;: \&quot;TOO_MANY_SEGMENTS\&quot;,             \&quot;args\&quot;: {                 \&quot;maxSegments\&quot;: 40000,                 \&quot;segments\&quot;: 400009             },             \&quot;message\&quot;: \&quot;Up to 40000 segments can be opened in the Memsource Web Editor, job has 400009 segments\&quot;         }     ] } &#x60;&#x60;&#x60;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiWebEditorLinkOpts - Optional Parameters:
     * @param "Body" (optional.Interface of CreateWebEditorLinkDto) -

@return WebEditorLinkDto
*/

type JobApiWebEditorLinkOpts struct {
	Body optional.Interface
}

func (a *JobApiService) WebEditorLink(ctx context.Context, projectUid string, localVarOptionals *JobApiWebEditorLinkOpts) (WebEditorLinkDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue WebEditorLinkDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/webEditor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(CreateWebEditorLinkDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be CreateWebEditorLinkDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v WebEditorLinkDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Get Web Editor URL
 Possible warning codes are:   - &#x60;NOT_ACCEPTED_BY_LINGUIST&#x60; - Job is not accepted by linguist   - &#x60;NOT_ASSIGNED_TO_LINGUIST&#x60; - Job is not assigned to linguist   - &#x60;PDF&#x60; - One of requested jobs is PDF   - &#x60;PREVIOUS_WORKFLOW_NOT_COMPLETED&#x60; - Previous workflow step is not completed   - &#x60;PREVIOUS_WORKFLOW_NOT_COMPLETED_STRICT&#x60; - Previous workflow step is not completed and project has strictWorkflowFinish set to true   - &#x60;IN_DELIVERED_STATE&#x60; - Jobs in DELIVERED state   - &#x60;IN_COMPLETED_STATE&#x60; - Jobs in COMPLETED state   - &#x60;IN_REJECTED_STATE&#x60; - Jobs in REJECTED state  Possible error codes are:   - &#x60;ASSIGNED_TO_OTHER_USER&#x60; - Job is accepted by other user   - &#x60;NOT_UNIQUE_TARGET_LANG&#x60; - Requested jobs contains different target locales   - &#x60;TOO_MANY_SEGMENTS&#x60; - Count of requested job&#39;s segments is higher than **40000**   - &#x60;COMPLETED_JOINED_WITH_OTHER&#x60; - Jobs in COMPLETED state cannot be joined with jobs in other states   - &#x60;DELIVERED_JOINED_WITH_OTHER&#x60; - Jobs in DELIVERED state cannot be joined with jobs in other states   - &#x60;REJECTED_JOINED_WITH_OTHER&#x60; - Jobs in REJECTED state cannot be joined with jobs in other states  Warning response example: &#x60;&#x60;&#x60; {     \&quot;warnings\&quot;: [         {             \&quot;message\&quot;: \&quot;Not accepted by linguist\&quot;,             \&quot;args\&quot;: {                 \&quot;jobs\&quot;: [                     \&quot;abcd1234\&quot;                 ]             },             \&quot;code\&quot;: \&quot;NOT_ACCEPTED_BY_LINGUIST\&quot;         },         {             \&quot;message\&quot;: \&quot;Previous workflow step not completed\&quot;,             \&quot;args\&quot;: {                 \&quot;jobs\&quot;: [                     \&quot;abcd1234\&quot;                 ]             },             \&quot;code\&quot;: \&quot;PREVIOUS_WORKFLOW_NOT_COMPLETED\&quot;         }     ],     \&quot;url\&quot;: \&quot;/web/job/abcd1234-efgh5678/translate\&quot; } &#x60;&#x60;&#x60;  Error response example: Status: &#x60;400 Bad Request&#x60; &#x60;&#x60;&#x60; {     \&quot;errorCode\&quot;: \&quot;NOT_UNIQUE_TARGET_LANG\&quot;,     \&quot;errorDescription\&quot;: \&quot;Only files with identical target languages can be joined\&quot;,     \&quot;errorDetails\&quot;: [         {             \&quot;code\&quot;: \&quot;NOT_UNIQUE_TARGET_LANG\&quot;,             \&quot;args\&quot;: {                 \&quot;targetLocales\&quot;: [                     \&quot;de\&quot;,                     \&quot;en\&quot;                 ]             },             \&quot;message\&quot;: \&quot;Only files with identical target languages can be joined\&quot;         },         {             \&quot;code\&quot;: \&quot;TOO_MANY_SEGMENTS\&quot;,             \&quot;args\&quot;: {                 \&quot;maxSegments\&quot;: 40000,                 \&quot;segments\&quot;: 400009             },             \&quot;message\&quot;: \&quot;Up to 40000 segments can be opened in the Memsource Web Editor, job has 400009 segments\&quot;         }     ] } &#x60;&#x60;&#x60;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param optional nil or *JobApiWebEditorLinkV2Opts - Optional Parameters:
     * @param "Body" (optional.Interface of CreateWebEditorLinkDtoV2) -

@return WebEditorLinkDtoV2
*/

type JobApiWebEditorLinkV2Opts struct {
	Body optional.Interface
}

func (a *JobApiService) WebEditorLinkV2(ctx context.Context, projectUid string, localVarOptionals *JobApiWebEditorLinkV2Opts) (WebEditorLinkDtoV2, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue WebEditorLinkDtoV2
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/webEditor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(CreateWebEditorLinkDtoV2)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be CreateWebEditorLinkDtoV2")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v WebEditorLinkDtoV2
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Wildcard search job&#39;s translation memories

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiWildCardSearchByJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of WildCardSearchByJobRequestDto) -

@return SearchResponseListTmDto
*/

type JobApiWildCardSearchByJobOpts struct {
	Body optional.Interface
}

func (a *JobApiService) WildCardSearchByJob(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiWildCardSearchByJobOpts) (SearchResponseListTmDto, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v1/projects/{projectUid}/jobs/{jobUid}/transMemories/wildCardSearch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(WildCardSearchByJobRequestDto)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be WildCardSearchByJobRequestDto")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDto
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Wildcard search job&#39;s translation memories

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiWildCardSearchByJob2Opts - Optional Parameters:
     * @param "Body" (optional.Interface of WildCardSearchByJobRequestDtoV2) -

@return SearchResponseListTmDtoV2
*/

type JobApiWildCardSearchByJob2Opts struct {
	Body optional.Interface
}

func (a *JobApiService) WildCardSearchByJob2(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiWildCardSearchByJob2Opts) (SearchResponseListTmDtoV2, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDtoV2
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v2/projects/{projectUid}/jobs/{jobUid}/transMemories/wildCardSearch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(WildCardSearchByJobRequestDtoV2)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be WildCardSearchByJobRequestDtoV2")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDtoV2
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
JobApiService Wildcard search job&#39;s translation memories

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectUid
 * @param jobUid
 * @param optional nil or *JobApiWildCardSearchByJob3Opts - Optional Parameters:
     * @param "Body" (optional.Interface of WildCardSearchByJobRequestDtoV3) -

@return SearchResponseListTmDtoV3
*/

type JobApiWildCardSearchByJob3Opts struct {
	Body optional.Interface
}

func (a *JobApiService) WildCardSearchByJob3(ctx context.Context, projectUid string, jobUid string, localVarOptionals *JobApiWildCardSearchByJob3Opts) (SearchResponseListTmDtoV3, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SearchResponseListTmDtoV3
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api2/v3/projects/{projectUid}/jobs/{jobUid}/transMemories/wildCardSearch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectUid"+"}", fmt.Sprintf("%v", projectUid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobUid"+"}", fmt.Sprintf("%v", jobUid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(WildCardSearchByJobRequestDtoV3)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be WildCardSearchByJobRequestDtoV3")
		}
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SearchResponseListTmDtoV3
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
